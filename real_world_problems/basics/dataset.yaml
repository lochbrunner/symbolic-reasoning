declarations:
  f:
    is_fixed: true
    is_function: true
    only_root: false
rules:
  trivial subtraction: a-a => 0
  trivial division: a/a => 1
  trivial multiplication: 0*a => 0 
  # counting
  counting 2: 1+1 => 2
  counting 3: 1+2 => 3
  # counting down (Could be deduced from above later)
  de-counting 2: 2-1 => 1
  de-counting 3: 3-1 => 2
  de-counting 4: 4-1 => 3
  doubling: a+a => 2*a
  # others
  commutative property 1: a*b <=> b*a
  commutative property 2: a+b <=> b+a
  associative property: a*(b*c) => (a*b)*c 
  distributive property 1: a*(b+c) => a*b+a*c
  distributive property 2: a*(b-c) => a*b-a*c
  # neutrals
  neutral sum: a+0 => a
  neutral subtraction: a-0 => a
  neutral product: 1*a => a
  neutral division: a/1 => a
  # exponentiation
  square: a*a <=> a^2
  next exponent: a*a^n => a^(n+1)
  neutral exponent: a^1 => a
  trivial exponent: a^0 => 1
  # equations
  equation 1: a - b = 0 => a = b
  equation 3: a / b = 1 => a = b
premises:
 - x = y
 - x = 0
 - x = 1
 - x = y + z
 - x = y^2
 - x = y / z
problems:
  one step: 3/3 => 1
  two steps: 3/(1+2) => 1
  # binomial formula (a+b)(a+b) => (a+b)*a + (a+b)*b => a*a+b*a + (a+b)*b => a*a+b*a + a*b+b*b
  three steps: (a+b)(a+b) => a*a+b*a + a*b+b*b
  four steps: (a+b)^2 => a*a+b*a + a*b+b*b
  five steps: (a+b)^2 => a*a+b*a + b*a+b*b
  six steps: (a+b)^2 => a*a + 2*b*a + b*b
  seven steps: (a+b)^2 => a^2 + 2*b*a + b*b
  eight steps: (a+b)^2 => a^2 + 2*b*a + b^2
files:
  trainings-data: &bag out/generator/bag-basic.bin
generation:
  # stages: [4,4, 4, 4, 4, 4, 4, 4, 4, 4, 4]
  stages: [2,2,2,2,2,2,2]
  max-depth: 9
training:
  save-model: snapshots/bag-basic.sp
  device: cpu
  # Learning
  num-epochs: 30
  batch-size: 32
  learning-rate: 0.1 # Not needed here
  gradient-clipping: 0.1
  model: TreeCnnSegmenter
  # Scenario
  scenario: bag
  filename: *bag

evaluation: {}
